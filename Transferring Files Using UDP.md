
#NetworkingCoreNodeJS 

## Problems with File Transfer Over UDP

- **Packet size limit** â†’ Cannot send packets larger than ~65KB
- **No retransmission** â†’ Lost packets are not automatically resent
- **No acknowledgment** â†’ Receiver does not confirm received data

---

## 1. Never use `setEncoding('utf8')` for Binary Files

- MP4/images/videos are binary.
- `setEncoding` converts bytes â†’ text â†’ bytes â†’ corrupts data.
- Keep chunks as raw **Buffer**.

## 2. Readable Stream Read Cycle

1. Node fills internal buffer (`highWaterMark`).
2. Emits `'data'` / `'readable'`.
3. You read chunk â†’ buffer empties â†’ Node refills.
4. At end: `'end'` event and `.read()` returns null.

## 3. Get File Size

```js
let size = (await stat(path)).size;
```

## 4. Track Progress

```js
let percent = (readStream.bytesRead / size) * 100;
```

  
## 5. Avoid Flooding UDP (Pause/Resume)

```js
readStream.pause();
socket.send(chunk, () => readStream.resume());
```

  
## 6. UDP Auto-Bind

- `socket.send()` without `bind()` â†’ OS picks random port.
- Bind manually for replies:

```js
socket.bind(3000);
```

  
## 7. UDP is Unreliable

- Packets may be lost, duplicated, or out of order.
- No guarantee of delivery.
- For reliability: TCP or sequence numbers + ACKs.


## 8. Send EOF Control Packet

Sender:
```js
socket.send('EOF');
```

Receiver:
```js
if (msg.toString() === 'EOF') writeStream.end();
```

  
## 9. Write Binary Correctly

```js
writeStream.write(chunk); // Buffer
writeStream.end(); Â  Â  Â  Â // finish
```

## 10. Safe UDP Chunk Size

- Keep packets <1400 bytes.
- 1000 bytes is ideal.

  
## 11. Percentage Display

```js
process.stdout.clearLine(0);
process.stdout.cursorTo(0);
process.stdout.write(percent + "%");
```


---
`client.js`
```js
import { readFile, stat } from "fs/promises"
import dgram from 'dgram'
import { createReadStream } from "fs"

let readStream = createReadStream("C:\\Users\\Devin\\Desktop\\Deva Deva.mp4", { highWaterMark: 1000 })
let fileDetails = await stat("C:\\Users\\Devin\\Desktop\\Deva Deva.mp4")
let socket = dgram.createSocket('udp4')

socket.on('message', (data, rinfo) => {
Â  Â  console.log(data.toString());
Â  Â  socket.close()
})

socket.bind({ port: 3000 }, () => {
Â  Â  console.log('sent from ->', socket.address().port);
})

readStream.on('data', (chunk) => {
Â  Â  socket.send(chunk, 2000, '192.168.1.10', (err, sentBytes) => {
Â  Â  Â  Â  updatePercent((readStream.bytesRead / fileDetails.size) * 100);
Â  Â  },)
})

readStream.on('end', () => {
Â  Â  socket.send('EOF', 2000, '192.168.1.10')
})

function updatePercent(percent) {
Â  Â  process.stdout.clearLine(0); Â  // clear current line
Â  Â  process.stdout.cursorTo(0); Â  Â // move cursor to start
Â  Â  process.stdout.write(`${percent}%`);
}

```

`Server.js`
```js
import dgram from 'dgram'
import { createWriteStream } from 'fs'
import { writeFile } from 'fs/promises'

  
let writeStream = createWriteStream('music.mp4')
let socket = dgram.createSocket('udp4')


socket.on('message', async (data, rinfo) => {
Â  Â  if (data.toString() == 'EOF') {
Â  Â  Â  Â  socket.send(`\nMsg Recieved Over -> ${socket.address().port}`, rinfo.port, rinfo.address)
Â  Â  } else {
Â  Â  Â  Â  writeStream.write(data)
Â  Â  Â  Â  console.log(data);
Â  Â  }
})

socket.bind(2000, '192.168.1.10', () => {
Â  Â  console.log(socket.address());
Â  Â  const address = socket.address();
Â  Â  console.log(`Listening on port ${address.port}`);
})

```


---

Code Generated By GPT : `After Handling Errors` | 

---

```JS
// client.js
import { stat } from 'fs/promises';
import { createReadStream } from 'fs';
import dgram from 'dgram';

const FILE = "C:\\Users\\Devin\\Desktop\\Deva Deva.mp4";
const LOCAL_PORT = 3000;
const REMOTE_PORT = 2000;
const REMOTE_HOST = '192.168.1.10';
const CHUNK_SIZE = 1000; // bytes

const fileStat = await stat(FILE);
const fileSize = fileStat.size;

const socket = dgram.createSocket('udp4');
socket.on('error', (err) => { console.error('socket error', err); socket.close(); });
socket.bind(LOCAL_PORT, () => console.log('bound', socket.address()));

// read stream (emit Buffers)
const rs = createReadStream(FILE, { highWaterMark: CHUNK_SIZE });
rs.pause();

let sentBytes = 0;

rs.on('data', (chunk) => {
  // chunk is a Buffer â€” do NOT convert to string
  rs.pause(); // backpressure: wait until this packet sent
  socket.send(chunk, REMOTE_PORT, REMOTE_HOST, (err, bytes) => {
    if (err) {
      console.error('send error', err);
      socket.close();
      rs.destroy(err);
      return;
    }
    sentBytes += bytes;
    updatePercent((sentBytes / fileSize) * 100);
    rs.resume();
  });
});

rs.on('end', () => {
  // send EOF as a separate datagram (small control message)
  socket.send(Buffer.from('EOF'), REMOTE_PORT, REMOTE_HOST, (err) => {
    if (err) console.error('EOF send error', err);
    // close socket after a short delay to let last packet go
    setTimeout(() => socket.close(), 200);
  });
});

rs.on('error', (err) => {
  console.error('read stream error', err);
  socket.close();
});

function updatePercent(percent) {
  const p = Math.min(100, Math.max(0, Math.floor(percent))); // clamp & integer
  process.stdout.clearLine(0);
  process.stdout.cursorTo(0);
  process.stdout.write(`${p}%`);
}

// start sending after bind
rs.resume();

```


```JS
// server.js (receiver)
import dgram from 'dgram';
import { createWriteStream } from 'fs';

const OUTPUT = 'music.mp4';
const LISTEN_PORT = 2000;
const LISTEN_ADDR = '192.168.1.10';

const ws = createWriteStream(OUTPUT);
const server = dgram.createSocket('udp4');

server.on('message', (msg, rinfo) => {
  // msg is a Buffer
  if (msg.length === 3 && msg.toString() === 'EOF') {
    console.log('Received EOF from', rinfo);
    ws.end(() => console.log('File write finished.'));
    // optional: send acknowledgement back to sender
    const ack = Buffer.from(`ACK:${server.address().port}`);
    server.send(ack, rinfo.port, rinfo.address, (err) => {
      if (err) console.error('ACK error', err);
    });
    return;
  }

  // normal binary chunk: write directly
  ws.write(msg, (err) => {
    if (err) console.error('write error', err);
  });
});

server.on('listening', () => {
  console.log('Server listening', server.address());
});

server.bind(LISTEN_PORT, LISTEN_ADDR);

```

ğŸ”¥UDP is useful only when you need ultra-fast and lightweight transfer without guaranteed reliability.
If you still want to use  UDP then :
âš ï¸ *All reliability features must be manually implemented by the developer*
Better Solution is TCP instead :
TCP automatically:
- Maintains **order**
- Performs **error-checking**
- Handles **retransmission**
- Provides **reliable** file transfer


[[Creating TCP Server in Node.js]]